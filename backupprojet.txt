(** Projet Polish -- Analyse statique d'un mini-langage impératif *)

(** Note : cet embryon de projet est pour l'instant en un seul fichier
    polish.ml. Il est recommandé d'architecturer ultérieurement votre
    projet en plusieurs fichiers source de tailles raisonnables *)

(*****************************************************************************)
(** Syntaxe abstraite Polish (types imposés, ne pas changer sauf extensions) *)

(** Position : numéro de ligne dans le fichier, débutant à 1 *)
type position = int

(** Nom de variable *)
type name = string

(** Opérateurs arithmétiques : + - * / % *)
type op = Add | Sub | Mul | Div | Mod

(** Expressions arithmétiques *)
type expr =
  | Num of int
  | Var of name
  | Op of op * expr * expr

(** Opérateurs de comparaisons *)
type comp =
| Eq (* = *)
| Ne (* Not equal, <> *)
| Lt (* Less than, < *)
| Le (* Less or equal, <= *)
| Gt (* Greater than, > *)
| Ge (* Greater or equal, >= *)

(** Condition : comparaison entre deux expressions *)
type cond = expr * comp * expr

(** Instructions *)
type instr =
  | Set of name * expr
  | Read of name
  | Print of expr
  | If of cond * block * block
  | While of cond * block
and block = (position * instr) list

(** Un programme Polish est un bloc d'instructions *)
type program = block

type file_line = { number : position ; content : string}

 let is_operator word = 
  match word with
    | "+" -> true
    | "-"  -> true
    | "*" -> true
    | "/" -> true
    | "%" -> true
    | _ -> false  
  ;;
  
  (*Permet de savoir le si le mot est un nombre*)
let is_number word =  
  match word with
    | "0" -> true
    | "1"  -> true
    | "2" -> true
    | "3" -> true
    | "4" -> true
    | "5" -> true
    | "6" -> true
    | "7" -> true
    | "8" -> true
    | "9" -> true
    | _ -> false  
    ;;
  
  let get_operator word = 
  match word with
    | "+" -> Add
    | "-"  -> Sub
    | "*" -> Mul
    | "/" -> Div
    | _ -> Mod   
    ;;
    
    (*Construit une instruction avec une liste de mot sans le mot clé*)
let rec construct_expression list_of_words = 
  let first_word = List.nth list_of_words 0 in
  if is_operator first_word then
    let num_1 = List.nth list_of_words 1 in
    let num_2 = List.nth list_of_words 2 in
    let exp_1 = construct_expression [num_1] in
    let exp_2 = construct_expression [num_2] in
    Op (get_operator first_word, exp_1, exp_2)

  else if is_number first_word then
    Num (int_of_string first_word)

  else  
    Var (first_word)
    ;;
    
     let rec list_without_first_elements list current_iteration min_iteration  = 
  match list with
  | [] -> []
  | element::sublist ->
    if current_iteration < min_iteration then
      list_without_first_elements sublist (current_iteration+1) min_iteration
    else
      let resultList = list_without_first_elements sublist (current_iteration+1) min_iteration in
      element :: resultList
      ;;

(*Prend une liste de mot et renvoie une instruction*)
let make_instruction list_of_words first_word = 
  match first_word with
  | "COMMENT" -> Read "t" 
  | "READ" -> Read first_word
  | "PRINT" -> Print (construct_expression list_of_words)
  | "IF" -> Read "t"
  | "WHILE" -> Read "t"
  | _ -> 
    let sub_list_of_words = list_without_first_elements list_of_words 0 1 in
    Set (first_word, (construct_expression sub_list_of_words))

        ;;   

let rec list_without_first list iteration = 
  match list with
  | [] -> []
  | element::sublist ->
    if iteration == 0 then
      list_without_first sublist 1
    else
      let resultList = list_without_first sublist (iteration+1) in
      element :: resultList
      ;;
      

      
(*Explore la liste des lignes et renvoie une liste de block*)
let rec convert_string_to_block list_of_lines = 
  match list_of_lines with 
  | [] -> []
  | element::sub_list_of_lines -> 
      let list_result = convert_string_to_block sub_list_of_lines in
      let list_of_words = String.split_on_char ' ' element.content in
      let first_word = List.nth list_of_words 0 in

      if first_word = "COMMENT" then
        list_result

      else
        let sub_list_of_words = list_without_first_elements list_of_words 0 1 in
        (element.number, make_instruction sub_list_of_words first_word)::list_result
      ;;
      

      
list_without_first [1;2;3] 0;;
list_without_first_elements [1;2;3] 0 1;;
convert_string_to_block [{ number = 1; content = "COMMENT valeur absolue"}; { number = 2; content = "res := - 0 n"}; { number = 3; content = "PRINT n"}];;
convert_string_to_block [];;
convert_string_to_block [];;

is_operator "-";;
get_operator "%";;

int_of_string "1";;